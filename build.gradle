import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
/*
    1.Java plugin adds java compilation along with testing and bundling capabilities
        Read more at https://docs.gradle.org/current/userguide/java_plugin.html
    2.The Application plugin facilitates creating an executable JVM application.
        Read more at https://docs.gradle.org/current/userguide/application_plugin.html
 */
plugins {
    id 'java'
    id 'application'
    id 'idea'
}

/*
    This specifies a mandatory configuration for the plugin application.
    The configuration shows the entry point of the application/project.
 */
application{
    mainClass = "com.tudu.Main"
}

group 'org.example'
//version '1.0-SNAPSHOT'

/*
    This shows from where the dependencies are going to be pulled from
 */
repositories {
    mavenCentral()
}

/*
    QA : What is this? Also test is part of src, should they be separate?
 */
sourceSets {
    main {
        java {
            srcDirs = ['src']
        }
    }
}

/*
    Dependencies are requirements for building your application/library itself
    Here the dependency is JUnit
 */
dependencies {
    implementation 'org.junit.jupiter:junit-jupiter-engine:5.7.1'
    implementation 'org.junit.jupiter:junit-jupiter-params:5.7.1'
    implementation 'org.fusesource.jansi:jansi:2.2.0'
}

/*
    For the build to understand that JUnit be used for testing
 */
test {
    useJUnitPlatform()
    testLogging {
        events 'PASSED', 'SKIPPED', 'FAILED'
        //showStandardStreams = true
    }
}
/*
    Below code is taken from
    https://gist.github.com/lwasyl/f5b2b4ebe9e348ebbd8ee4cb995f8362#file-gradle_tests_report-gradle
 */
import org.gradle.api.tasks.testing.logging.TestExceptionFormat
import org.gradle.api.tasks.testing.logging.TestLogEvent
import groovy.time.TimeCategory
ext.testsResults = [] // Container for tests summaries

allprojects { project ->
    tasks.withType(Test) { testTask ->

        testTask.testLogging { logging ->
            events TestLogEvent.FAILED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_OUT,
                    TestLogEvent.STANDARD_ERROR

            exceptionFormat TestExceptionFormat.FULL
            showExceptions true
            showCauses true
            showStackTraces true
        }

        ignoreFailures = true // Always try to run all tests for all modules

        afterSuite { desc, result ->

            if (desc.parent) return // Only summarize results for whole modules

            String summary = "${testTask.project.name}:${testTask.name} results: ${result.resultType} " +
                    "(" +
                    "${result.testCount} tests, " +
                    "${result.successfulTestCount} successes, " +
                    "${result.failedTestCount} failures, " +
                    "${result.skippedTestCount} skipped" +
                    ") " +
                    "in ${TimeCategory.minus(new Date(result.endTime), new Date(result.startTime))}" +
                    "\n" +
                    "Report file: ${testTask.reports.html.entryPoint}"

            // Add reports in `testsResults`, keep failed suites at the end
            if (result.resultType == TestResult.ResultType.SUCCESS) {
                rootProject.testsResults.add(0, summary)
            } else {
                rootProject.testsResults += summary
            }
        }
    }
}


gradle.buildFinished {
    def allResults = rootProject.ext.testsResults

    if (!allResults.isEmpty()) {
        printResults allResults
    }
}

private static void printResults(allResults) {
    def maxLength = allResults*.readLines().flatten().collect { it.length() }.max()

    println "┌${"${"─" * maxLength}"}┐"

    println allResults.collect {
        it.readLines().collect {
            "│" + it + " " * (maxLength - it.length()) + "│"
        }.join("\n")
    }.join("\n├${"${"─" * maxLength}"}┤\n")

    println "└${"${"─" * maxLength}"}┘"
}

/*tasks.withType(Test) {
    testLogging {
        // set options for log level LIFECYCLE
        events TestLogEvent.FAILED,
                TestLogEvent.PASSED,
                TestLogEvent.SKIPPED,
                TestLogEvent.STANDARD_OUT
        exceptionFormat TestExceptionFormat.FULL
        showExceptions true
        showCauses true
        showStackTraces true

        // set options for log level DEBUG and INFO
        debug {
            events TestLogEvent.STARTED,
                    TestLogEvent.FAILED,
                    TestLogEvent.PASSED,
                    TestLogEvent.SKIPPED,
                    TestLogEvent.STANDARD_ERROR,
                    TestLogEvent.STANDARD_OUT
            exceptionFormat TestExceptionFormat.FULL
        }
        info.events = debug.events
        info.exceptionFormat = debug.exceptionFormat

        afterSuite { desc, result ->
            if (!desc.parent) { // will match the outermost suite
                def output = "Results: ${result.resultType} (${result.testCount} tests, ${result.successfulTestCount} passed, ${result.failedTestCount} failed, ${result.skippedTestCount} skipped)"
                def startItem = '|  ', endItem = '  |'
                def repeatLength = startItem.length() + output.length() + endItem.length()
                println('\n' + ('-' * repeatLength) + '\n' + startItem + output + endItem + '\n' + ('-' * repeatLength))
            }

        }
    }
}*/
